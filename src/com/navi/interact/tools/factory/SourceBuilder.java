package com.navi.interact.tools.factory;

import com.navi.interact.tools.entity.Entity;
import com.navi.interact.tools.entity.EntityProperty;
import com.navi.interact.tools.util.DBUtils;
import com.navi.interact.tools.wrapper.FindUsing;
import com.navi.interact.tools.wrapper.Wrapper;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Properties;

/**
 * Created by mevan on 25/05/2016.
 */
public class SourceBuilder {

    private static String SYSTEM_USER="SYSTEM_USER";
    private static String CURRENT_DATE="CURRENT_DATE";
    private static String CURRENT_TIMESTAMP="CURRENT_TIMESTAMP";

    private static final String TAB = "    ";

    private DocumentBuilderFactory dbFactory;
    private DocumentBuilder dBuilder;
    private File xml;
    private Document doc;
    private Properties prop;

    private String systemUser;

    private Entity entity;
    private Wrapper wrapper;

    private static SourceBuilder singleton = null;

    private SourceBuilder() throws Exception {
        prop = new Properties();
        prop.load(new FileInputStream(PropertyKey.DYNAMICDB_PROPERTIES_FILE));
        dbFactory = DocumentBuilderFactory.newInstance();
        dBuilder = dbFactory.newDocumentBuilder();
        xml = new File(prop.getProperty(PropertyKey.ENTITY_NAMES_XML_KEY));
        doc = dBuilder.parse(xml);
        doc.getDocumentElement().normalize();
        // systemUser = System.
    }

    public static SourceBuilder getInstance() throws Exception {
        if (singleton == null) {
            singleton = new SourceBuilder();
        }
        return singleton;
    }

    private void buildEntitySource(Node entityNode, String name) throws Exception {

        entity = new Entity();
        String pkgName = prop.getProperty(PropertyKey.ENTITY_BUILD_PKG_KEY).replace('/','.');
        System.out.println(pkgName);

        File entitySource = new File(prop.getProperty(PropertyKey.SRC_FOLDER_KEY) + prop.getProperty(PropertyKey.ENTITY_BUILD_PKG_KEY)+"/"+name+".java");
        System.out.println(entitySource.getPath());
        if (entitySource.exists()) {
            entitySource.delete();
        }
        entitySource.createNewFile();

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(entitySource)));

        writer.write("package "+pkgName+";\n\n");
        writer.write("import java.util.*;\n");
        writer.write("import org.apache.logging.log4j.LogManager;\n");
        writer.write("import org.apache.logging.log4j.Logger;\n");
        writer.write("import "+entity.getClass().getPackage().getName()+"."+entity.getClass().getSimpleName()+";\n\n");

        writer.write("// Autogenerated - Do not change the code. TimeStamp: "+ Calendar.getInstance().getTime() +"\n");
        writer.write("public class "+name+" extends Entity {\n\n");

        NodeList propertyList = entityNode.getChildNodes();
        if(propertyList != null) {

            writer.write(TAB +"private static final Logger LOGGER = LogManager.getLogger("+name+".class);\n\n");

            writer.write(TAB +"public static final String BEAN_ID = \""+name+"\";\n\n");

            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);
                    writer.write(TAB + "private " + eProp.getType() + " " + eProp.getName() + ";\n");
                }
            }
            writer.write("\n");

            writer.write(TAB +"// Default constructor\n");
            writer.write(TAB +"public "+name+"() {\n");
            writer.write(TAB +"}\n");

            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);

                    //if (!(eProp.isPkey() && eProp.isSequence())) {
                    writer.write(TAB + "public void " + DBUtils.getMethodName(false, eProp) + "(" + eProp.getType() + " " + eProp.getName() + ") {;\n");
                    writer.write(TAB + TAB + "this." + eProp.getName() + "=" + eProp.getName() + ";\n");
                    writer.write(TAB + "}\n");
                    //}

                    writer.write(TAB + "public " + eProp.getType() + " " + DBUtils.getMethodName(true, eProp) + "() {\n");
                    writer.write(TAB + TAB + "return " + eProp.getName() + ";\n");
                    writer.write(TAB + "}\n");
                }
            }

            writer.write(TAB +"public void disclose() {\n");
            writer.write(TAB + TAB +"LOGGER.info(\""+name+" instance: \"+ this.hashCode());\n");
            writer.write(TAB + TAB +"StringBuffer sb = new StringBuffer();\n");
            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);
                    writer.write(TAB + TAB +"sb.append(\""+eProp.getName()+": \"+"+eProp.getName()+"+\"\\n\");\n");
                }
            }
            writer.write(TAB + TAB +"LOGGER.info(sb.toString());\n");
            writer.write(TAB +"}\n");

        }
        writer.write("}\n");

        writer.flush();
    }

    private void buildWrapperSource(Node entityNode, String name) throws Exception {

        String className = name+"Wrapper";
        wrapper = new Wrapper();
        String pkgName = prop.getProperty(PropertyKey.WRAPPER_BUILD_PKG_KEY).replace('/','.');
        System.out.println(pkgName);

        File wrapperSource = new File(prop.getProperty(PropertyKey.SRC_FOLDER_KEY) + prop.getProperty(PropertyKey.WRAPPER_BUILD_PKG_KEY)+"/"+className+".java");
        System.out.println(wrapperSource.getPath());
        if (wrapperSource.exists()) {
            wrapperSource.delete();
        }
        wrapperSource.createNewFile();

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(wrapperSource)));

        writer.write("package "+pkgName+";\n\n");
        writer.write("import java.sql.*;\n");
        writer.write("import java.util.*;\n");
        writer.write("import java.util.Date;\n");
        writer.write("import com.navi.interact.tools.util.*;\n");
        writer.write("import org.apache.logging.log4j.LogManager;\n");
        writer.write("import org.apache.logging.log4j.Logger;\n");

        String entityPkgName = prop.getProperty(PropertyKey.ENTITY_BUILD_PKG_KEY).replace('/','.');
        writer.write("import "+entityPkgName+".*;\n");


        writer.write("import "+wrapper.getClass().getPackage().getName()+".*;\n\n");
        writer.write("import "+wrapper.getClass().getPackage().getName()+"."+wrapper.getClass().getSimpleName()+";\n\n");

        writer.write("// Autogenerated - Do not change the code. TimeStamp: "+ Calendar.getInstance().getTime() +"\n");
        writer.write("public class "+className+" extends Wrapper {\n\n");

        NodeList propertyList = entityNode.getChildNodes();
        ArrayList<Node> newList = new ArrayList<Node>();
        for(int i=0; i<propertyList.getLength(); i++) {
            Node property = propertyList.item(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                newList.add(property);
            }
        }

        writer.write(TAB +"private static final Logger LOGGER = LogManager.getLogger("+className+".class);\n\n");
        writer.write(TAB +"public static final String TABLE_NAME = \""+name+"\";\n\n");

        writer.write(TAB +"public static final String BEAN_ID = \""+className+"\";\n\n");

        if(propertyList != null) {
            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);
                    writer.write(TAB +"public static final String "+eProp.getName().toUpperCase()+" = \""+name+"."+eProp.getName()+"\";\n");
                }
            }
            writer.write("\n");

            writer.write(TAB +"private Statement stmt;\n");

            writer.write("\n");
            writer.write(TAB +"// Default constructor\n");
            writer.write(TAB +"public "+className+"() throws Exception {\n");
            writer.write(TAB + TAB +"stmt = connection.createStatement();\n");
            writer.write(TAB +"}\n");

            writer.write(TAB +"public "+name+"[] getAll() throws Exception {\n");
            writer.write(TAB + TAB +"String sql = "+"\"SELECT * FROM "+name+"\";\n");
            writer.write(TAB + TAB +"ResultSet rset = stmt.executeQuery(sql);\n");
            writer.write(TAB + TAB +"return this.getResults(rset);\n");
            writer.write(TAB +"}\n");

            writer.write(TAB +"public "+name+"[] executeDynamicQuery(Enum findUsingEnumValue, String dynamicClause) throws Exception {\n");

            writer.write(TAB + TAB +"String findUsing = null;\n");
            writer.write(TAB + TAB +"if (findUsingEnumValue.equals(FindUsing.WHERE)) {\n");
            writer.write(TAB + TAB + TAB+"findUsing = DBUtils.WHERE;\n");
            writer.write(TAB + TAB +"} else if (findUsingEnumValue.equals(FindUsing.INNER_JOIN)) {\n");
            writer.write(TAB + TAB + TAB+"findUsing = DBUtils.INNER_JOIN;\n");
            writer.write(TAB + TAB +"} else if (findUsingEnumValue.equals(FindUsing.OUTER_JOIN)) {\n");
            writer.write(TAB + TAB + TAB+"findUsing = DBUtils.OUTER_JOIN;\n");
            writer.write(TAB + TAB +"}\n");

            writer.write(TAB + TAB +"String sql = \"SELECT * FROM "+DBUtils.getCamelCaseWord(name)+" \"+findUsing+\" \"+dynamicClause+\";\";\n");
            writer.write(TAB + TAB +"LOGGER.debug(sql);\n");
            writer.write(TAB + TAB +"ResultSet rset = stmt.executeQuery(sql);\n");
            writer.write(TAB + TAB +"return this.getResults(rset);\n");
            writer.write(TAB +"}\n");

            writer.write(TAB +"public boolean insert("+name+" "+name.toLowerCase()+") throws Exception {\n");
            StringBuffer sb = new StringBuffer();
            StringBuffer val = new StringBuffer();
            for(int i=0; i<newList.size(); i++) {
                Node property = newList.get(i);
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isPkey() && !eProp.isSequence()) {
                    sb.append(eProp.getName());
                    if ( eProp.getType().toLowerCase().equals("int") ) {
                        val.append("\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()+\"");
                    }
                    if (i+1 < newList.size()) {
                        sb.append(",");
                        val.append(",");
                    }
                }
                if (!eProp.isPkey()) {
                    sb.append(eProp.getName());
                    if ( eProp.getType().toLowerCase().equals("string") || eProp.getType().toLowerCase().equals("date") ) {
                        val.append("\"+(("+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()!=null)?"+"\"'\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()"+"+\"'\""+":null)+\"");
                    } else if( eProp.getType().toLowerCase().equals("boolean")) {
                        val.append("'\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()+\"'");
                    } else  {
                        val.append("\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()+\"");
                    }
                    if (i+1 < newList.size()) {
                        sb.append(",");
                        val.append(",");
                    }
                }
            }
            writer.write(TAB + TAB +"String sql = \"INSERT INTO "+name+"("+sb.toString()+")\";\n");
            writer.write(TAB + TAB +"String values = \"VALUES("+val.toString()+")\";\n");
            writer.write(TAB + TAB +"LOGGER.debug(sql+values);\n");
            writer.write(TAB + TAB +"return stmt.execute(sql+values);\n");
            writer.write(TAB +"}\n");

            writer.write(TAB +"public boolean update("+name+" "+name.toLowerCase()+") throws Exception {\n");
            sb = new StringBuffer();
            StringBuffer pk = new StringBuffer();
            pk.append(" WHERE ");
            for(int i=0; i<newList.size(); i++) {
                Node property = newList.get(i);
                EntityProperty eProp = new EntityProperty(property);
                if (!eProp.isPkey()) {
                    sb.append(eProp.getName()+"=");
                    if ( eProp.getType().toLowerCase().equals("string") || eProp.getType().toLowerCase().equals("date") ) {
                        sb.append("\"+(("+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()!=null)?"+"\"'\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()"+"+\"'\""+":null)+\"");
                    } else if( eProp.getType().toLowerCase().equals("boolean")) {
                        sb.append("'\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()+\"'");
                    } else  {
                        sb.append("\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()+\"");
                    }
                    if (i+1 < newList.size()) {
                        sb.append(",");
                    }
                } else {
                    pk.append(eProp.getName()+"=\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()");
                }
            }
            writer.write(TAB + TAB +"String sql = \"UPDATE "+name+" SET "+sb.toString()+pk.toString()+";\n");
            writer.write(TAB + TAB +"LOGGER.debug(sql);\n");
            writer.write(TAB + TAB +"return stmt.execute(sql);\n");
            writer.write(TAB +"}\n");

            writer.write(TAB +"public boolean delete("+name+" "+name.toLowerCase()+") throws Exception {\n");
            sb = new StringBuffer();
            pk = new StringBuffer();
            pk.append(" WHERE ");
            for(int i=0; i<newList.size(); i++) {
                Node property = newList.get(i);
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isPkey()) {
                    pk.append(eProp.getName()+"=\"+"+name.toLowerCase()+"."+DBUtils.getMethodName(true, eProp)+"()");
                }
            }
            writer.write(TAB + TAB +"String sql = \"DELETE FROM "+name+pk.toString()+";\n");
            writer.write(TAB + TAB +"LOGGER.debug(sql);\n");
            writer.write(TAB + TAB +"return stmt.execute(sql);\n");
            writer.write(TAB +"}\n");

            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);
                    writer.write(TAB +"public "+name+"[] get"+name+"By"+ DBUtils.getCamelCaseWord(eProp.getName())+"("+eProp.getType()+" "+eProp.getName()+") throws Exception {\n");
                    if (eProp.getType().toLowerCase().equals("string") || eProp.getType().toLowerCase().equals("date") || eProp.getType().toLowerCase().equals("boolean")) {
                        writer.write(TAB + TAB +"String sql = "+"\"SELECT * FROM "+name+" WHERE "+eProp.getName()+"='\"+"+eProp.getName()+"+\"'\";\n");
                    } else {
                        writer.write(TAB + TAB +"String sql = "+"\"SELECT * FROM "+name+" WHERE "+eProp.getName()+"=\"+"+eProp.getName()+";\n");
                    }
                    writer.write(TAB + TAB +"LOGGER.debug(sql);\n");
                    writer.write(TAB + TAB +"ResultSet rset = stmt.executeQuery(sql);\n");
                    writer.write(TAB + TAB +"return this.getResults(rset);\n");
                    writer.write(TAB +"}\n");
                }
            }

            writer.write(TAB +"\n");
            writer.write(TAB +"private "+name+"[] getResults(ResultSet rset) throws Exception {\n");
            writer.write(TAB + TAB +"ArrayList<"+name+"> "+name.toLowerCase()+"List = new ArrayList<"+name+">();\n");
            writer.write(TAB + TAB +"while(rset.next()) {\n");
            writer.write(TAB + TAB + TAB + name+" "+name.toLowerCase()+" = new "+name+"();\n");
            for(int i=0; i<propertyList.getLength(); i++) {
                Node property = propertyList.item(i);
                if (property.getNodeType() == Node.ELEMENT_NODE) {
                    EntityProperty eProp = new EntityProperty(property);
                    writer.write(TAB + TAB + TAB + name.toLowerCase()+".set"+DBUtils.getCamelCaseWord(eProp.getName())+"(rset.get"+DBUtils.getCamelCaseWord(eProp.getType())+"(\""+eProp.getName()+"\"));\n");
                }
            }
            writer.write(TAB + TAB + TAB +name.toLowerCase()+"List.add("+name.toLowerCase()+");\n");

            writer.write(TAB + TAB +"}\n");

            writer.write(TAB + TAB +name+"[] "+name.toLowerCase()+"s = new "+name+"["+name.toLowerCase()+"List.size()];;\n");
            writer.write(TAB + TAB +"for (int i=0; i<"+name.toLowerCase()+"List.size(); i++) {;\n");
            writer.write(TAB + TAB + TAB +name.toLowerCase()+"s[i] = "+name.toLowerCase()+"List.get(i);;\n");
            writer.write(TAB + TAB +"}\n");

            writer.write(TAB + TAB +"return "+name.toLowerCase()+"s;\n");
            writer.write(TAB +"}\n");
        }
        writer.write("}\n");
        writer.flush();
    }

    private BufferedWriter buildCreateTablesSQLScript() throws Exception {
        String scriptName = prop.getProperty(PropertyKey.CREATE_TABLE_SCRIPT);;
        String pkgName = this.getClass().getPackage().getName();

        File scriptSource = new File(scriptName);
        System.out.println(scriptSource.getPath());
        if (scriptSource.exists()) {
            scriptSource.delete();
        }
        scriptSource.createNewFile();
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(scriptSource)));

        return writer;
    }

    private void buildCreateTables(BufferedWriter writer, Node entityNode, ArrayList<Node> parentNodes, String name) throws Exception {

        NodeList propertyList = entityNode.getChildNodes();
        ArrayList<Node> newList = new ArrayList<Node>();

        for(int i=0; i<propertyList.getLength(); i++) {
            Node property = propertyList.item(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                newList.add(property);
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isPkey() && eProp.isSequence() && eProp.getType().equals("int")) {
                    writer.write("CREATE SEQUENCE IF NOT EXISTS "+name+"_"+eProp.getName()+"_seq START 1;\n");
                }
            }
        }

        NodeList parentPropertyList = parentNodes.get(0).getChildNodes();
        for(int i=0; i<parentPropertyList.getLength(); i++) {
            Node property = parentPropertyList.item(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                newList.add(property);
            }
        }

        writer.write("CREATE TABLE IF NOT EXISTS "+name+" (\n");

        for(int i=0; i<newList.size(); i++) {
            Node property = newList.get(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                String type = null;
                if (eProp.getType().toLowerCase().equals("int")) {
                    type = "int";
                    if (eProp.isPkey() && eProp.isSequence()) {
                        type += " PRIMARY KEY default nextval('"+name+"_"+eProp.getName()+"_seq')";
                    }
                    if (eProp.isPkey() && !eProp.isSequence()) {
                        type += " PRIMARY KEY ";
                    }
                } else if (eProp.getType().toLowerCase().equals("string")) {
                    type = "character";
                    if(eProp.getLength() > 0) {
                        type += "("+eProp.getLength()+") ";
                    } else {
                        type += "(1) ";
                    }
                    if (eProp.isPkey()) {
                        type += " PRIMARY KEY";
                    }
                } else if (eProp.getType().toLowerCase().equals("date")) {
                    type = "date";
                } else if (eProp.getType().toLowerCase().equals("long")) {
                    type = "bigint";
                } else if (eProp.getType().toLowerCase().equals("double")) {
                    if (eProp.getPrecision() != null && eProp.getScale() != null) {
                        type = "numeric("+eProp.getPrecision()+","+eProp.getScale()+")";
                    } else {
                        type = "numeric(6,2)";
                    }
                } else if (eProp.getType().toLowerCase().equals("numeric")) {
                    if (eProp.getPrecision() != null && eProp.getScale() != null) {
                        type = "numeric("+eProp.getPrecision()+","+eProp.getScale()+")";
                    } else {
                        type = "numeric(6,2)";
                    }
                } else if (eProp.getType().toLowerCase().equals("boolean")) {
                    type = "boolean";
                } else if (eProp.getType().toLowerCase().equals("timestamp")) {
                    type = "timestamp";
                }

                if (eProp.isNotNull()) {
                    type += " NOT NULL";
                }

                if (eProp.getDefauktValue() != null) {
                    if (eProp.getType().toLowerCase().equals("string")) {
                        if (eProp.getDefauktValue().equals(SYSTEM_USER)) {
                            type += " default current_user";
                        }
                    } else if (eProp.getType().toLowerCase().equals("date")) {
                        if (eProp.getDefauktValue().equals(CURRENT_DATE)) {
                            type += " default "+CURRENT_DATE;
                        }
                    } else if (eProp.getType().toLowerCase().equals("timestamp")) {
                        if (eProp.getDefauktValue().equals(CURRENT_TIMESTAMP)) {
                            type += " default current_timestamp";
                        }
                    }
                }

                if (i+1 == newList.size()) {
                    writer.write(TAB + eProp.getName()+" "+type+"\n");
                } else {
                    writer.write(TAB + eProp.getName()+" "+type+",\n");
                }
            }
        }
        writer.write(");\n");

        for(int i=0; i<propertyList.getLength(); i++) {
            Node property = propertyList.item(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isIndex()) {
                    writer.write("CREATE INDEX IF NOT EXISTS "+name+"_"+eProp.getName()+"_idx ON "+name+" ("+eProp.getName()+");\n");
                }
            }
        }

        writer.flush();
    }

    private BufferedWriter buildDeleteTablesSQLScript() throws Exception {
        String scriptName = prop.getProperty(PropertyKey.DELETE_TABLE_SCRIPT);
        String pkgName = this.getClass().getPackage().getName();

        File scriptSource = new File(scriptName);
        // File scriptSource = new File(prop.getProperty(PropertyKey.SRC_FOLDER_KEY) + prop.getProperty(PropertyKey.SCRIPT_SRC_FOLDER_KEY) + "/" + scriptName);
        System.out.println(scriptSource.getPath());
        if (scriptSource.exists()) {
            scriptSource.delete();
        }
        scriptSource.createNewFile();

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(scriptSource)));
        return writer;
    }

    private void buildDeleteTablesSQLScript(BufferedWriter writer, Node node) throws Exception {
        String name = node.getAttributes().getNamedItem("name").getNodeValue();
        writer.write("DROP TABLE IF EXISTS "+name+";\n");
        writer.flush();
    }

    private void buildDeleteIndexsAndForeignKeys(BufferedWriter writer, Node node) throws Exception {

        NodeList propertyList = node.getChildNodes();
        String name = node.getAttributes().getNamedItem("name").getNodeValue();

        for(int i=0; i<propertyList.getLength(); i++) {
            Node property = propertyList.item(i);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isIndex()) {
                    writer.write("DROP INDEX IF EXISTS "+name+"_"+eProp.getName()+"_idx;\n");
                }
            }
        }

        for(int j=0; j<propertyList.getLength(); j++) {
            Node property = propertyList.item(j);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.getFKey() != null && !eProp.getFKey().isEmpty()) {
                    writer.write("ALTER TABLE "+name+" DROP CONSTRAINT " + name + "_" + eProp.getName() + "_fkey;\n");
                }
            }
        }
        writer.flush();
    }

    private void buildDeleteSequences(BufferedWriter writer, Node node) throws Exception {

        NodeList propertyList = node.getChildNodes();
        String name = node.getAttributes().getNamedItem("name").getNodeValue();

        for(int j=0; j<propertyList.getLength(); j++) {
            Node property = propertyList.item(j);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.isPkey() && eProp.isSequence() && eProp.getType().equals("int")) {
                    writer.write("DROP SEQUENCE IF EXISTS " + name + "_" + eProp.getName() + "_seq;\n");
                }
            }
        }
        writer.flush();
    }

    private void buildForeignKeys(BufferedWriter writer, Node node) throws Exception {
        NodeList propertyList = node.getChildNodes();
        String name = node.getAttributes().getNamedItem("name").getNodeValue();

        for(int j=0; j<propertyList.getLength(); j++) {
            Node property = propertyList.item(j);
            if (property.getNodeType() == Node.ELEMENT_NODE) {
                EntityProperty eProp = new EntityProperty(property);
                if (eProp.getFKey() != null && !eProp.getFKey().isEmpty()) {
                    writer.write("ALTER TABLE " + name + " ADD CONSTRAINT " + name+"_" + eProp.getName() + "_fkey \n");
                    writer.write("   FOREIGN KEY ("+eProp.getName()+") REFERENCES " + eProp.getFKey() + " MATCH SIMPLE ON UPDATE CASCADE ON DELETE CASCADE;\n");
                }
            }
        }
        writer.flush();
    }

    private BufferedWriter buildBeansXML() throws Exception {
        String scriptName = prop.getProperty(PropertyKey.SRC_FOLDER_KEY)+"/"+prop.getProperty(PropertyKey.BEANS_XML_KEY);;
        String pkgName = this.getClass().getPackage().getName();

        File scriptSource = new File(scriptName);
        System.out.println(scriptSource.getPath());
        if (scriptSource.exists()) {
            scriptSource.delete();
        }
        scriptSource.createNewFile();
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(scriptSource)));

        return writer;
    }

    private void buildBeansXMLPrefixData(BufferedWriter writer) throws Exception {
        writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");

        writer.write("<beans xmlns=\"http://www.springframework.org/schema/beans\"\n");
        writer.write("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n");
        writer.write("xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n");
        writer.write("http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n");

        writer.flush();
    }

    private void buildBeansXMLSuffixData(BufferedWriter writer) throws Exception {
        writer.write("</beans>\n");
        writer.flush();
    }

    private void buildBeansEntity(BufferedWriter writer, String name) throws Exception {
        String pkgName = prop.getProperty(PropertyKey.ENTITY_BUILD_PKG_KEY).replace('/','.')+".";
        writer.write("  <bean id=\""+name+"\" class=\""+pkgName+name+"\"/>\n");
        writer.flush();
    }

    private void buildBeansWrapper(BufferedWriter writer, String name) throws Exception {
        String pkgName = prop.getProperty(PropertyKey.WRAPPER_BUILD_PKG_KEY).replace('/','.')+".";
        writer.write("  <bean id=\""+name+"Wrapper\" class=\""+pkgName+name+"Wrapper\"/>\n");
        writer.flush();
    }

    public void buildSource() throws Exception {

        NodeList nList = doc.getElementsByTagName("Entities").item(0).getChildNodes();
        ArrayList<Node> parentNodes = new ArrayList<Node>();
        BufferedWriter writerC = this.buildCreateTablesSQLScript();
        BufferedWriter writerD = this.buildDeleteTablesSQLScript();
        BufferedWriter writerB = this.buildBeansXML();

        for (int i=0; i < nList.getLength(); i++) {
            Node entityNode = nList.item(i);
            if (entityNode.getNodeType() == Node.ELEMENT_NODE && entityNode.getNodeName().equals("BaseEntity")) {
                parentNodes.add(entityNode);
            }
        }

        for (int i=0; i < nList.getLength(); i++) {
            Node entityNode = nList.item(i);
            if (entityNode.getNodeType() == Node.ELEMENT_NODE && entityNode.getNodeName().equals("Entity")) {
                String name = entityNode.getAttributes().getNamedItem("name").getNodeValue();

                this.buildEntitySource(entityNode, name);
                this.buildWrapperSource(entityNode, name);

                this.buildCreateTables(writerC, entityNode, parentNodes, name);
                this.buildDeleteIndexsAndForeignKeys(writerD, entityNode);
                this.buildForeignKeys(writerC, entityNode);

                System.out.println("---"+name);
            }
        }

        for (int i=0; i < nList.getLength(); i++) {
            Node entityNode = nList.item(i);
            if (entityNode.getNodeType() == Node.ELEMENT_NODE && entityNode.getNodeName().equals("Entity")) {
                String name = entityNode.getAttributes().getNamedItem("name").getNodeValue();
                this.buildDeleteTablesSQLScript(writerD, entityNode);
            }
        }

        for (int i=0; i < nList.getLength(); i++) {
            Node entityNode = nList.item(i);
            if (entityNode.getNodeType() == Node.ELEMENT_NODE && entityNode.getNodeName().equals("Entity")) {
                String name = entityNode.getAttributes().getNamedItem("name").getNodeValue();
                this.buildDeleteSequences(writerD, entityNode);
            }
        }

        this.buildBeansXMLPrefixData(writerB);
        for (int i=0; i < nList.getLength(); i++) {
            Node entityNode = nList.item(i);
            if (entityNode.getNodeType() == Node.ELEMENT_NODE && entityNode.getNodeName().equals("Entity")) {
                String name = entityNode.getAttributes().getNamedItem("name").getNodeValue();
                this.buildBeansEntity(writerB, name);
                this.buildBeansWrapper(writerB, name);
            }
        }
        this.buildBeansXMLSuffixData(writerB);

    }

    public static void main(String[] args) throws Exception {
        SourceBuilder factory = SourceBuilder.getInstance();
        factory.buildSource();
    }

}
